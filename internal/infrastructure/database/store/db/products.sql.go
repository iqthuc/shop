// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: products.sql

package db

import (
	"context"
	"database/sql"

	"github.com/shopspring/decimal"
)

const getProductDetails = `-- name: GetProductDetails :one
SELECT
    p.id,
    p.name,
    p.slug,
    p.desciprtion,
    p.main_image_url,
    p.base_price,
    c.id AS category_id,
    c.name AS category_name,
    b.id AS brand_id,
    b.name AS brand_name
FROM
    products p
LEFT JOIN
    categories c ON p.category_id = c.id
LEFT JOIN
    brands b ON p.brand_id = b.id
WHERE
    p.id = $1
GROUP BY
    p.id, c.id, c.name, b.id, b.name
`

type GetProductDetailsRow struct {
	ID           int32           `json:"id"`
	Name         string          `json:"name"`
	Slug         string          `json:"slug"`
	Desciprtion  sql.NullString  `json:"desciprtion"`
	MainImageUrl sql.NullString  `json:"main_image_url"`
	BasePrice    decimal.Decimal `json:"base_price"`
	CategoryID   int32           `json:"category_id"`
	CategoryName sql.NullString  `json:"category_name"`
	BrandID      int32           `json:"brand_id"`
	BrandName    sql.NullString  `json:"brand_name"`
}

func (q *Queries) GetProductDetails(ctx context.Context, id int32) (GetProductDetailsRow, error) {
	row := q.db.QueryRow(ctx, getProductDetails, id)
	var i GetProductDetailsRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Slug,
		&i.Desciprtion,
		&i.MainImageUrl,
		&i.BasePrice,
		&i.CategoryID,
		&i.CategoryName,
		&i.BrandID,
		&i.BrandName,
	)
	return i, err
}

const getProductVariants = `-- name: GetProductVariants :many
SELECT
	pv.id,
	pv.product_id,
	pv.sku,
	pv.price,
	pv.stock_quantity,
	pv.sold,
	pv.image_url,
	pv.is_default
FROM
	product_variants pv
	LEFT JOIN variant_attribute_values AS vav ON pv.id = vav.variant_id
	LEFT JOIN attribute_values AS av ON vav.value_id = av.id
	LEFT JOIN "attributes" AS a ON av.attribute_id = a.id
WHERE product_id = $1
GROUP BY pv.id
`

func (q *Queries) GetProductVariants(ctx context.Context, productID int32) ([]ProductVariant, error) {
	rows, err := q.db.Query(ctx, getProductVariants, productID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ProductVariant{}
	for rows.Next() {
		var i ProductVariant
		if err := rows.Scan(
			&i.ID,
			&i.ProductID,
			&i.Sku,
			&i.Price,
			&i.StockQuantity,
			&i.Sold,
			&i.ImageUrl,
			&i.IsDefault,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProducts = `-- name: GetProducts :many
SELECT id, name, base_price
FROM products
WHERE ($3::text = '' OR name ILIKE '%' || $3 || '%')
ORDER BY
    CASE WHEN $4::varchar = 'price' AND $5::varchar = 'asc' THEN base_price END ASC,
    CASE WHEN $4::varchar = 'price' AND $5::varchar = 'desc' THEN base_price END DESC,
    CASE WHEN $4::varchar = 'name' AND $5::varchar = 'asc' THEN name END ASC,
    CASE WHEN $4::varchar = 'name' AND $5::varchar = 'desc' THEN name END DESC
LIMIT $1 OFFSET $2
`

type GetProductsParams struct {
	Limit         int32  `json:"limit"`
	Offset        int32  `json:"offset"`
	KeyWord       string `json:"key_word"`
	SortColumn    string `json:"sort_column"`
	SortDirection string `json:"sort_direction"`
}

type GetProductsRow struct {
	ID        int32           `json:"id"`
	Name      string          `json:"name"`
	BasePrice decimal.Decimal `json:"base_price"`
}

func (q *Queries) GetProducts(ctx context.Context, arg GetProductsParams) ([]GetProductsRow, error) {
	rows, err := q.db.Query(ctx, getProducts,
		arg.Limit,
		arg.Offset,
		arg.KeyWord,
		arg.SortColumn,
		arg.SortDirection,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetProductsRow{}
	for rows.Next() {
		var i GetProductsRow
		if err := rows.Scan(&i.ID, &i.Name, &i.BasePrice); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProductsCount = `-- name: GetProductsCount :one
SELECT COUNT(*) FROM products
`

func (q *Queries) GetProductsCount(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, getProductsCount)
	var count int64
	err := row.Scan(&count)
	return count, err
}
