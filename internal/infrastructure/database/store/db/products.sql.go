// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: products.sql

package db

import (
	"context"
)

const getProducts = `-- name: GetProducts :many
SELECT id, name, base_price::float8
FROM products
WHERE ($3::text = '' OR name ILIKE '%' || $3 || '%')
ORDER BY
    CASE WHEN $4::varchar = 'price' AND $5::varchar = 'asc' THEN base_price END ASC,
    CASE WHEN $4::varchar = 'price' AND $5::varchar = 'desc' THEN base_price END DESC,
    CASE WHEN $4::varchar = 'name' AND $5::varchar = 'asc' THEN name END ASC,
    CASE WHEN $4::varchar = 'name' AND $5::varchar = 'desc' THEN name END DESC
LIMIT $1 OFFSET $2
`

type GetProductsParams struct {
	Limit         int32  `json:"limit"`
	Offset        int32  `json:"offset"`
	KeyWord       string `json:"key_word"`
	SortColumn    string `json:"sort_column"`
	SortDirection string `json:"sort_direction"`
}

type GetProductsRow struct {
	ID        int32   `json:"id"`
	Name      string  `json:"name"`
	BasePrice float64 `json:"base_price"`
}

func (q *Queries) GetProducts(ctx context.Context, arg GetProductsParams) ([]GetProductsRow, error) {
	rows, err := q.db.Query(ctx, getProducts,
		arg.Limit,
		arg.Offset,
		arg.KeyWord,
		arg.SortColumn,
		arg.SortDirection,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetProductsRow{}
	for rows.Next() {
		var i GetProductsRow
		if err := rows.Scan(&i.ID, &i.Name, &i.BasePrice); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProductsCount = `-- name: GetProductsCount :one
SELECT COUNT(*) FROM products
`

func (q *Queries) GetProductsCount(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, getProductsCount)
	var count int64
	err := row.Scan(&count)
	return count, err
}
